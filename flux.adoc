:github: https://github.com/dsyer/reactive-notes
:master: {github}/blob/master
:parti: {master}/intro.adoc

In this article we continue the series on {parti}[Reactive Programming], we concentrate on explaining some concepts through actual code samples. The end result should be that you understand the power of the Reactive approach, but remember that with power comes responsibility. It's radical, and it's fundamental. It's "rip it up and start again" territory. So you will also hopefully appreciate that Reactive isn't a solution to all problems. In fact it isn't a solution to any problem, it merely facilitates the solution of a certain class of problems. The benefits you get from using it might be outweighed by the costs of learning it and maintaining the code afterwards, so tread carefully.

== Setting Up a Project

We will use the Reactor libraries and a bit of Spring 5.0 to illustrate the points we need to make. The code could just as easily be written with other tools. If you want to play with the code and see it working without having to copy-paste anything, there are working samples with tests in {github}[Github].

To get started grab a blank project from https://start.spring.io and add the Reactor Core dependency. With Maven 

```xml
		<dependency>
			<groupId>io.projectreactor</groupId>
			<artifactId>reactor-core</artifactId>
			<version>2.5.0.BUILD-SNAPSHOT</version>
		</dependency>
```

With Gradle it's very similar:

```java
    compile 'io.projectreactor:reactor-core:2.5.0.BUILD-SNAPSHOT'
```

TODO: update reactor version to stable release

Now let's write some code.

== What Makes it Functional?

The basic building block of Reactive is a stream of events, and two protagonists, a publisher and a subscriber to those events. It's OK to call it a "stream" because that's what it is. If we need to, we will use the word "stream" with a small "s", but Java 8 has a `java.util.Stream` which is different, so try not to get confused. We will try to concentrate the narrative on the publisher and subscriber anyway (that's what Reactive Streams does).

Reactor is the library we are going to use in samples, so we'll stick to the notation there, and call the publisher a `Flux` (it implements the interface `Publisher` from Reactive Streams). The RxJava library is very similar and has a lot of parallel features, so in that case we would be talking about an `Observable` instead, but the code would be very similar. (Reactor 2.0 called it a `Stream` which is confusing if we need to talk about Java 8 `Streams` as well, so we'll only use the new code in Reactor 2.5.)

=== Generators

A `Flux` is a publisher of a stream of events of a specific POJO type, so it is generic, i.e. `Flux<T>` is a publisher of `T`. `Flux` has some static convenience methods to create instances of itself from a variety of sources. For example, to create a `Flux` from an array:

```java
Flux<String> flux = Flux.just("red", "white", "blue");
```

We just generated a `Flux`, and now we can do stuff with it. There are actually only three things you can do with it: operate on it (transform it, or combine it with other streams), subscribe to it (it's a publisher), or configure it (modify the behaviour of subscribers).

=== Single Valued Streams

Often you encounter a stream that you know has only one or zero elements, for example a repository method that finds an entity by its id. Reactor has a `Mono` type representing a single valued or empty `Flux`. `Mono` has a very similar API to `Flux` but more focused because not all operators make sense for single-valued streams. RxJava also has a bolt on (in version 1.x) called `Single`, and also `Completable` for an empty stream.

=== Operators

There are a _lot_ of methods on a `Flux` and nearly all of them are operators. We aren't going to look at them all here because there are better places to look for that (like the Javadocs). We only need to get a flavour for what an operator is, and what it can do for you.

For instance, to ask for the internal events inside a `Flux` to be logged to standard out, you can call the `.log()` method. Or you can transform it using a `map()`:

```java
Flux<String> flux = Flux.just("red", "white", "blue");

Flux<String> upper = flux
  .log()
  .map(value -> value.toUpperCase());
```

In this code we transformed the strings in the input by converting them to upper case. So far, so trivial.

What's interesting about this little sample -- mind blowing, even, if you're not used to it -- is that no data have been processed yet. Nothing has even been logged because literally, nothing happened (try it and you will see). Calling operators on a `Flux` amounts to building a plan of execution for later. It is completely declarative, and it's why people call it "functional". The logic implemented in the operators is only executed when data starts to flow, and that doesn't happen until someone subscribes to the `Flux` (or equivalently to the `Publisher`).

The same declarative, functional approach to processing a stream of data exists in all Reactive libraries, and also in Java 8 `Streams`. Consider this, similar looking code, using a `Stream` with the same contents as the `Flux`:

```java
Stream<String> stream = Streams.of("red", "white", "blue");
Stream<String> upper = stream.map(value -> {
    System.out.println(value);
    return value.toUpperCase();
});
```

The observation we made about `Flux` applies here: no data is processed, it's just a plan of execution. There are, however, some important differences between `Flux` and `Stream` though, which make `Stream` an inappropriate API for Reactive use cases. `Flux` has a lot more operators, much of which is just convenience, but the real difference comes when you want to consume the data, so that's what we need to look at next.

TIP: There is a useful blog by Sebastien Deleuze on https://spring.io/blog/2016/04/19/understanding-reactive-types[Reactive Types], where he describes the differences between the various streaming and reactive APIs by looking at the types they define, and how you would use them. The differences between `Flux` and `Stream` are highlighted there in more detail.

=== Subscribers

To make the data flow you have to subscribe to the `Flux` using one of the `subscribe()` methods. Only those methods make the data flow. They reach back through the chain of operators you declared on your stream (if any) and request the publisher to start creating data. In the sample samples we have been working with, this means the underlying collection of strings is iterated. In more complicated use case it might trigger a file to be read from the filesystem, or a pull from a database or a call to an HTTP service.

Here's a call to `subscribe()` in action:

```java
Flux.just("red", "white", "blue");
  .log()
  .map(value -> value.toUpperCase())
.subscribe()
```

The output is:

```
09:17:59.665 [main] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxIterable$IterableSubscription@3ffc5af1)
09:17:59.666 [main] INFO reactor.core.publisher.FluxLog -  request(unbounded)
09:17:59.666 [main] INFO reactor.core.publisher.FluxLog -  onNext(red)
09:17:59.667 [main] INFO reactor.core.publisher.FluxLog -  onNext(white)
09:17:59.667 [main] INFO reactor.core.publisher.FluxLog -  onNext(blue)
09:17:59.667 [main] INFO reactor.core.publisher.FluxLog -  onComplete()
```

So we can see from this that the effect of `subscribe()` without an argument, is to request the publisher to send _all_ data -- there's only one `request()` logged and it's "unbounded". We can also see callbacks for each item that is published (`onNext`), for the end of the stream (`onComplete`), and for the original subscription (`onSubscribe`). If you needed to you could listen for those events yourself using the `doOn*()` methods in `Flux` (which are themselves operators, not subscribers, so they don't cause any data to flow on their own).

The `subscribe()` method is overloaded, and the other variants give you different options to control what happens. One important and convenient form is `subscribe()` with callbacks as arguments. The first argument is a `Consumer`, which gives you a callback with each of the items, and you can also optionally add a `Consumer` for an error if there is one, and a vanilla `Runnable` to execute when the stream is complete. For example, just with the per-item callback:

```java
Flux.just("red", "white", "blue");
    .log()
    .map(value -> value.toUpperCase())
.subscribe(System.out::println);
```

Here's the output:

```
09:56:12.680 [main] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxArray$ArraySubscription@59f99ea)
09:56:12.682 [main] INFO reactor.core.publisher.FluxLog -  request(unbounded)
09:56:12.682 [main] INFO reactor.core.publisher.FluxLog -  onNext(red)
RED
09:56:12.682 [main] INFO reactor.core.publisher.FluxLog -  onNext(white)
WHITE
09:56:12.682 [main] INFO reactor.core.publisher.FluxLog -  onNext(blue)
BLUE
09:56:12.682 [main] INFO reactor.core.publisher.FluxLog -  onComplete()
```

We could control the flow of data, and make it "bounded", in a variety of ways. The raw API for controlling it is the `Subscription` you get from a `Subscriber`. The equivalent long form of the short call to `subscribe()` above is:

```java
.subscribe(new Subscriber<String>() {

    @Override
    public void onSubscribe(Subscription s) {
        s.request(Long.MAX_VALUE);
    }
    @Override
        public void onNext(String t) {
    }
    @Override
        public void onError(Throwable t) {
    }
    @Override
        public void onComplete() {
    }

});
```

To control the flow, e.g. to consume at most 2 items at a time, you could use the `Subscription` more intelligently:

```java
.subscribe(new Subscriber<String>() {

    private long count = 0;
    private Subscription subscription;

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
        subscription.request(2);
    }

    @Override
    public void onNext(String t) {
        count++;
        if (count>=2) {
            count = 0;
            subscription.request(2);
        }
     }
...
```

This `Subscriber` is "batching" items 2 at a time. It's a common use case so you might want to extract the implementation to a convenience class, and that would make the code more readable too. The output looks like this:

```
09:47:13.562 [main] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxArray$ArraySubscription@61832929)
09:47:13.564 [main] INFO reactor.core.publisher.FluxLog -  request(2)
09:47:13.564 [main] INFO reactor.core.publisher.FluxLog -  onNext(red)
09:47:13.565 [main] INFO reactor.core.publisher.FluxLog -  onNext(white)
09:47:13.565 [main] INFO reactor.core.publisher.FluxLog -  request(2)
09:47:13.565 [main] INFO reactor.core.publisher.FluxLog -  onNext(blue)
09:47:13.565 [main] INFO reactor.core.publisher.FluxLog -  onComplete()
```

=== Configurers

In fact the batching subscriber is such a common use case that there are convenience methods already available in `Flux`. They fall into the category of "configurers", operating on the `Flux` itself and not on the data. Generally a configurer modifies the behaviour of subscribers before they are added. The batching example above can be implemented like this:

```java
Flux.just("red", "white", "blue");
  .log()
  .map(value -> value.toUpperCase())
  .useCapacity(2)
.subscribe()
```

(note the call to `useCapacity()` before the subscription). The output:

```
10:25:43.739 [main] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxArray$ArraySubscription@4667ae56)
10:25:43.740 [main] INFO reactor.core.publisher.FluxLog -  request(2)
10:25:43.740 [main] INFO reactor.core.publisher.FluxLog -  onNext(red)
10:25:43.741 [main] INFO reactor.core.publisher.FluxLog -  onNext(white)
10:25:43.741 [main] INFO reactor.core.publisher.FluxLog -  request(2)
10:25:43.741 [main] INFO reactor.core.publisher.FluxLog -  onNext(blue)
10:25:43.741 [main] INFO reactor.core.publisher.FluxLog -  onComplete()
```

TIP: A library that will process streams for you, like Spring Reactive Web, can handle the configuration concerns, as well as the subscriptions. It's good to be able to push these concerns down the stack because it saves you from cluttering your code with non-business logic, making it more readable and easier to test and maintain. So as a rule, it is a good thing if you can **avoid calling configurers**, or at least push that code into a processing layer, and out of the business logic.

=== Threads, Dispatchers and Background Processing

An interesting feature of all the logs above is that they are all on the "main" thread, which is the thread of the caller to `subscribe()`. This highlights an important point: Reactor is extremely frugal with threads, because that gives you the greatest chance of the best possible performance. That might be a surprising statement if you've been wrangling threads and thread pools and asynchronous executions for the last 5 years, trying to squeeze more juice out of your services. But it's true: in the absence of any imperative to switch threads, even if the JVM is optimized to handle threads very efficiently, it is always faster to do computation on a single thread. Reactor has handed you the keys to control all the asynchronous processing, and it assumes you know what you are doing.

`Flux` provides a few configurer methods that control the thread boundaries inside the eventual subscriber. For example, you can configure the subscriptions to be handled in a background thread using `Flux.subscribeOn()`:

```java
Flux.just("red", "white", "blue");
  .log()
  .map(String::toUpperCase)
  .subscribeOn(Executors.parallel())
.useCapacity(2)
.subscribe()
```

the result can be seen in the output:

```
13:43:41.279 [parallel-1-1] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxArray$ArraySubscription@58663fc3)
13:43:41.280 [parallel-1-1] INFO reactor.core.publisher.FluxLog -  request(2)
13:43:41.281 [parallel-1-1] INFO reactor.core.publisher.FluxLog -  onNext(red)
13:43:41.281 [parallel-1-1] INFO reactor.core.publisher.FluxLog -  onNext(white)
13:43:41.281 [parallel-1-1] INFO reactor.core.publisher.FluxLog -  request(2)
13:43:41.281 [parallel-1-1] INFO reactor.core.publisher.FluxLog -  onNext(blue)
13:43:41.281 [parallel-1-1] INFO reactor.core.publisher.FluxLog -  onComplete()
```

TIP: if you write this code yourself, or copy-paste it, remember to wait for the processing to stop before the JVM exits.

Note that the subscription, and all the processing, takes place on a background thread "parallel-1-1" -- this is the result of using `Executors.parallel()`, which is designed for dispatching CPU-intensive work (you don't care if it blocks because it all has to get done and it will only cost more to fan it out). We also want to be able to handle the opposite scenario, where the processing is I/O intensive and possibly blocking. In this case, you are adapting an underlying blocking API, and you just want to get it done as quickly as possible without blocking the caller. A thread pool is still your friend, and that's what you get from `Executors.concurrent()`. It's not appropriate for a fast consumer like our string transformation, but lets just look at what happens to the output when we switch executors:

```java
Flux.just("red", "white", "blue");
  .log()
  .map(String::toUpperCase)
  .subscribeOn(Executors.concurrent())
.useCapacity(2)
.subscribe()
```

```
13:52:24.017 [concurrent-2] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxArray$ArraySubscription@663d9dce)
13:52:24.019 [concurrent-2] INFO reactor.core.publisher.FluxLog -  request(2)
13:52:24.019 [concurrent-2] INFO reactor.core.publisher.FluxLog -  onNext(red)
13:52:24.020 [concurrent-2] INFO reactor.core.publisher.FluxLog -  onNext(white)
13:52:24.020 [concurrent-3] INFO reactor.core.publisher.FluxLog -  request(2)
13:52:24.020 [concurrent-3] INFO reactor.core.publisher.FluxLog -  onNext(blue)
13:52:24.020 [concurrent-3] INFO reactor.core.publisher.FluxLog -  onComplete()
```

Notice that there are now 2 threads processing the items, one for each "chunk" of data, separated by the "capacity" configuration. You might need to run this code a few times to get the same result because it's backed by a thread pool and the worker is selected essentially at random, so sometimes the same thread processes all the items.

TODO: Replace `Computations` with `Executors` (API change in Reactor 2.5.0.M3).

`Flux` also has a `publishOn()` method which is the same, but for the listeners (i.e. `onNext()` or consumer callbacks) instead of for the subscriber itself:

```java
Flux.just("red", "white", "blue");
  .log()
  .map(String::toUpperCase)
  .subscribeOn(Computations.concurrent())
  .publishOn(Executors.concurrent(), 2)
.subscribe(value -> {
    log.info("Consumed: " + value);
});
```

The output looks like this:

```
14:29:00.410 [concurrent-4] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxArray$ArraySubscription@53b06015)
14:29:00.412 [concurrent-4] INFO reactor.core.publisher.FluxLog -  request(2)
14:29:00.412 [concurrent-4] INFO reactor.core.publisher.FluxLog -  onNext(red)
14:29:00.412 [concurrent-4] INFO reactor.core.publisher.FluxLog -  onNext(white)
14:29:00.416 [parallel-1-1] INFO com.example.FluxFeaturesTests - Consumed: RED
14:29:00.416 [parallel-1-1] INFO com.example.FluxFeaturesTests - Consumed: WHITE
14:29:00.416 [concurrent-3] INFO reactor.core.publisher.FluxLog -  request(2)
14:29:00.416 [concurrent-3] INFO reactor.core.publisher.FluxLog -  onNext(blue)
14:29:00.416 [concurrent-3] INFO reactor.core.publisher.FluxLog -  onComplete()
14:29:00.416 [parallel-1-1] INFO com.example.FluxFeaturesTests - Consumed: BLUE
```

Notice that the consumer callbacks (logging "Consumed: ...") are on the publisher thread `parallel-1-1`. If you take out the `subscribeOn()` call, you might see all of the 2nd chunk of data processed on the `parallel-1-1` thread as well. This, again, is Reactor being frugal with threads -- if there's no explicit request to switch threads it stays on the same one for the next call, whatever that is.

=== Converters: The Subscribers from Dark Side

There is another way to subscribe to a stream, which is to call a converter method. `Flux` has `toStream()`, `toList()` and `toMap()`, and `Mono` has `get()` and `toFuture()`.

WARNING: A good rule of thumb is "**never call a converter**" (i.e. `get()` or the `to*()` methods on `Mono` and `Flux`).

These methods are only there as an escape hatch to bridge from Reactive to blocking, if you need to adapt to a legacy API, for instance. When you call `Mono.get()` you throw away all the benefits of the Reactive Streams. This is the key difference between Reactive Streams and Java 8 `Streams` -- the native Java `Stream` only has the "all or nothing" subscription model, the equivalent of `Mono.get()`. Of course `subscribe()` can block the calling thread as well, so it's just as dangerous as the converter methods, but you have more control -- you can prevent it from blocking by using `subscribeOn()` and you can drip the items through by applying back pressure and periodically deciding whether to continue.

== Conclusion

In this article we have covered the basics of the Reactive Streams and Reactor APIs. If you need to know more there are plenty of places to look, but there's no substitute for hands on coding, so use the code in {github}[GitHub] or head over to the https://github.com/reactor/lite-rx-api-hands-on[Lite RX Hands On] workshop if you need a place to start. So far, really this is just overhead, and we haven't learned much that we couldn't have done in a more obvious way using non-Reactive tools. The next article in the series will dig a little deeper into the blocking, dispatching and asynchronous sides of the Reactive model, and show you what opportunities there are to reap the real benefits of the whole approach.

